---
layout: post
title: 객체지향과 메모리구조
subtitle: Stack과 Heap, GC에 대해서
categories: easycode
tags: [easycode]
---

백발백중 4번째 강의는 객체지향의 요소들이 물리적 메모리에 어떻게 저장되고 움직이는가를 말한다.

![쉬운코드 4](/assets/images/0814/easy4.jpg)

### 1. 메모리구조

컴퓨터의 물리적 메모리 공간은 다음과 같이 이해할 수 있다.
이 메모리 공간은 용도에 따라 여러 영역으로 나뉘는데,
대표적으로 코드(Code) 영역, 데이터(Data) 영역, 힙(Heap) 영역, 스택(Stack) 영역이 있다.

코드 영역은 실행할 프로그램의 기계어 명령이 저장되는 공간이고,
데이터 영역은 프로그램 시작부터 종료까지 유지되는 전역 변수·정적 변수가 저장된다.
Heap 영역은 동적으로 생성되는 객체가 저장되며, Stack 영역은 함수 호출 시 생성되는 지역 변수와 매개변수, 그리고 호출 순서를 저장한다.

![물리적구조](/assets/images/0814/easy5.jpg)

이 중에서 Stack과 Heap은 Java에서 메모리 관리와 직접적으로 연결된다.
Stack 영역은 메서드 호출 시 생성되는 변수들을 저장하는 공간으로, 메서드가 종료되면 해당 영역이 자동으로 해제된다.
객체 그 자체보다는 포인터, 주소와 같은것을 다루는 곳이며
재귀 호출을 무한히 반복하거나 깊이가 과도해지면 **Stack Overflow**라는 런타임 오류가 발생한다.
반면 Heap 영역은 new 연산자로 생성된 객체가 저장되는 공간이며, 프로그램 전체에서 공유된다.
(JAVA에서 변수의 유효범위와는 무관하다.)
Heap 메모리를 잘 관리하지 않으면 **OutOfMemoryError**가 발생할 수 있다.

### 2. 값 타입 vs 참조 타입

Java에서 변수는 Stack에 저장되고,
이 변수가 값 타입(Primitive Type)일 경우 값 자체를, 참조 타입(Reference Type)일 경우 Heap에 있는 객체의 주소를 저장한다.
**객체(값)는 Heap에 저장된 실체 데이터로, 참조 변수가 있어야 접근 가능**하다.
값 타입에는 byte, short, int, long, float, double, char, boolean이 있으며, 값 복사 시 독립적으로 존재하므로 서로 영향을 주지 않는다.
반면 참조 타입은 주소를 복사하므로, 같은 객체를 가리키는 여러 변수가 존재할 수 있고, 한 쪽에서 객체를 변경하면 다른 쪽에도 영향을 준다.
(이에 따라 참조타입인 경우에는 이 변수가 어떤 객체와 연결되어있고 그 객체는 어떤 다른 변수와도 연결되어있는지 이해하며 사용해야한다.)

### 3. Garbage Collector

참조변수가 없다면, 해당 객체는 접근할 수도 사용할 수도 없는 객체가 **가비지 객체**가 되어버린다.
이 경우는 쓸모없이 차지하는 가비지 객체들을 없애야하는 Garbage Collector가 필요한데 이를 JAVA에서는 다른 언어에 비해 잘 자동화해놨다.
가비지 컬렉터는 일반적으로 다음과 같은 흐름으로 동작한다.

1. 도달 가능성 분석(Reachability Analysis)

- 프로그램의 실행 스레드, 스택, 전역 변수 등에서 출발해 참조 가능한 객체를 그래프 형태로 추적한다.
- 이 경로에 포함되지 않는 객체는 “도달 불가능(Unreachable)” 상태로 간주한다.

2. 수집(Mark and Sweep)

- 도달 가능한 객체에 “마크(Mark)”를 표시하고, 마크되지 않은 객체를 힙에서 제거한다.
- 필요 시 메모리를 압축(Compaction)하여 조각화를 방지한다.

3. 자동 실행 시점

- GC는 명확한 주기를 따르지 않고, JVM이 메모리 부족을 감지하거나 특정 조건을 만족했을 때 실행된다.
- 개발자가 System.gc()를 호출해 요청할 수 있지만, 즉시 실행을 보장하지 않는다.

이 방식의 가장 큰 장점은 개발자가 C/C++처럼 free()나 delete를 직접 호출하지 않아도 된다는 점이다. 수동 해제 과정에서 흔히 발생하는 메모리 누수(Leak)나 해제 후 접근(Dangling Pointer)과 같은 위험을 줄여 안정성을 높인다. Java의 자동 메모리 관리 모델은 특히 대규모 애플리케이션과 서버 환경에서 메모리 관리 부담을 크게 덜어주는 강점이 있다.

참고자료
https://www.youtube.com/watch?v=GIsr_r8XztQ&list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&index=4
https://www.youtube.com/watch?v=vZRmCbl871I
