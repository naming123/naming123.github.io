---
layout: post
title: 프로세스와 스레드의 차이
subtitle:  ContextSwitching
categories: easycode
tags: [easycode]
---

기술면접에서 나온 질문 중에서 가장 많이 언급되는 질문은
"멀티쓰레드와 멀티프로세스의 차이는?" 이라는 질문이다.

![banner](/assets/images/0818/easy5.jpg)

백엔드, 특히 "대규모트래픽"을 핵심소양으로 생각하는 회사들이라면 기본중의 기본으로 알아야 할 지식이다. 

#### 왜그럴까?

application을 실행되는 원리는
디스크(SSD/HDD 등)에 저장된 소스코드/컴파일언어로 이루어진 프로그램을 RAM에 올림으로써, 실행된다.

이때 RAM에 올라간 코드들은 

    #include <stdio.h>
    int g = 10;         // 전역 변수

    int main() {
        int x = 5;      // 지역 변수
        int *p = malloc(sizeof(int)); // 동적 메모리 할당
        *p = 20;
        printf("%d", g + x + *p);
        return 0;
    }

*p = 20;같은 힙 따로, x=5; 스택따로 코드 영역, 데이터 영역 따로 만들어지며 하나의 PCB블럭(프로세스)으로 만들어진다.

추가로, 프로세스 ID(PID), 레지스터 값(스냅샷), 메모리 주소 범위, 스케줄링 우선순위, 파일 핸들 정보 등도 같이 포함된다.


### 1. CPU 스케줄링


보통의 과정에서는 한 CPU가 여러 프로세스를 실행해야 한다.
이에 따라 원시적으로 CPU는 시분할(Time Sharing) 방식으로 프로세스 P1, P2, P3 등을 번갈아 실행하는 멀티프로그램 방식이었다.
- 실행 도중 발생하는 Context Switching:
- 현재 프로세스 상태(Context)를 저장 → 다른 프로세스로 전환 → 다시 불러오기.
- 오버헤드가 크고 성능 손실이 발생함.

### 2. 프로세스 vs. 스레드

![TaskManager](/assets/images/0818/taskManager.png)

같은 실행 파일을 여러 번 실행하면, 동일한 코드라도 서로 다른 프로세스가 생기기는 하지만, 원칙적으로는 하나의 실행 파일 당, **실행하면** 프로세스 하나가 생성된다.

프로세스는 독립된 메모리 공간을 가진


멀티프로세스:

- 프로세스 단위로 실행, 서로 독립적이라 안전.
- 하지만 Context Switching 비용이 큼.

멀티스레드:

- 하나의 프로세스 안에서 여러 스레드가 실행됨.
- 메모리를 공유하기 때문에 메모리 사용 효율적이고 빠름.
- 하지만 동기화 문제와 자원 충돌 가능성 존재.

### 3. Context Switching 비용

프로세스 전환 시:

- CPU 레지스터 값, 프로그램 카운터(PC), 메모리 매핑 정보까지 저장/복원 필요.
- 큰 오버헤드 발생.

스레드 전환 시:
- 같은 프로세스 내에서 실행 → 공유 메모리를 쓰므로 비교적 가벼움.

5. CPU 아키텍처와 가상화

그림에 VM(Virtual Machine)도 등장:

- OS 위에 또 다른 OS를 실행하는 방식.
- VM은 하이퍼바이저를 통해 CPU/메모리 자원을 나눔.
- 성능 오버헤드가 있음.

반대로 **Container(Docker)**는 OS 레벨 가상화라서 훨씬 가볍고 빠름.

6. 운영체제 비교

Windows vs Linux 언급:
- 각각 프로세스/스레드 관리 방식, 시스템 콜 처리 차이.
- 일반적으로 Linux가 서버용으로 효율적, Windows는 GUI 기반 사용 편리성 강점.

---

참고자료
https://www.youtube.com/watch?v=QmtYKZC0lMU&list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&index=6







