---
layout: post
title: Blog Start
subtitle: 블로그 시작하는법
categories: git
tags: [JAVA]
---

변수는 크게 값과 참조가 있다.

값 타입: 복사 전달
참조 타입: 주소 전달(실질적으로 같은 객체 참조)

### 선언방법

arg는 왜 맨날 String만 받을까?
스펙 때문에 그렇게 정해져 있음
자바 언어 명세(JLS)는 시작점(entry point)을 public static void main(String[] args) 로 못박아 둠.
varargs 표기 String... args 도 허용되지만, 컴파일되면 결국 String[] 로 동일해짐임.
운영체제 관점: 커맨드라인 인자는 원래 “문자열”임
유닉스/C도 char* argv[] 처럼 전부 텍스트로 들어옴.
자바 런처가 OS에서 받은 인자를 문자열(String) 객체 배열로 변환해 JVM에 넘김.
숫자/불리언처럼 보이는 값도 타입 정보가 없으므로 텍스트로만 전달됨.
런타임이 타입을 추측하지 않도록 한 설계
“첫 번째 인자는 int, 두 번째는 double” 같은 규칙을 런타임이 알 길이 없음.
여러 타입을 허용하게 하면 “어느 main을 부를지” 모호성이 생김 → 시작점 고정이 안전함.
따라서 항상 문자열로 받고, 필요한 타입은 개발자가 직접 파싱하도록 설계됨임.
실무적으로 얻는 효과
단일 진입 규약으로 도구/런처/빌드 시스템이 단순해짐.
인자 해석(필수/옵션, 기본값, 검증)은 도메인별 로직(예: picocli, commons-cli)로 명확히 처리함.

## 데이터타입


int vs Integer.parseInt

str vs char(아스키 접근가능)
inputstream을 받을 때 char로 인코딩을 하는데 string[]같은 걸 쓸 때 그러면 어떤 제약이나 가공이 들어가야되는건지?

str의 강점은?
StringBuilder와 append
repeat

'' vs ""

bw와 string.join이 안되는이유

str[] vs chartAt

int[]vs float[]
=> 배열과 다르다.

## 데이터변경
string.tochar
integer.parseInt
String.valueOf



## array vs list vs arraylist vs set(HashSet)
https://dev-coco.tistory.com/32#:~:text=%EC%A3%BC%EC%96%B4%EC%A7%84%20%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%97%90%20%EC%A0%80%EC%9E%A5%EB%90%9C%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EC%A3%BC%EC%96%B4%EC%A7%84%20%EA%B0%9D%EC%B2%B4%EB%A1%9C%20%EB%B0%94%EA%BE%BC%EB%8B%A4.,o)%2C%20%EC%A3%BC%EC%96%B4%EC%A7%84%20%EA%B0%9D%EC%B2%B4%EA%B0%80%20%EC%A0%80%EC%9E%A5%EB%90%98%EC%96%B4%20%EC%9E%88%EB%8A%94%EC%A7%80%20%EC%97%AC%EB%B6%80%20%ED%99%95%EC%9D%B8.
add/get/인덱스접근/해당조건인덱스출력/



Collections.frequency(AA, ch)
equals(string)

list/배열 출력방법 (with bw/sout) 
그래서 asList

배열과 []가 다른이유


========
cf) null / !=이나 =
왜 이런 일이 생기나

!= null 비교는 참조형(객체) 에만 가능함
예: String, Integer, Object …

int, double, char 같은 기본형은 null이라는 개념이 없고, 대신 기본값(0, 0.0, '\u0000')이 들어감

그래서 int 타입 값을 null과 비교하면

bad operand types for binary operator '!='
first type: int
second type: <null>


이런 컴파일 에러가 발생함







