<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://naming123.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://naming123.github.io/" rel="alternate" type="text/html" /><updated>2025-08-20T14:16:46+00:00</updated><id>https://naming123.github.io/feed.xml</id><title type="html">Naming123’s Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">Git branch</title><link href="https://naming123.github.io/git&project/2025/08/20/Project4-GitBranch%EA%B4%80%EB%A6%AC%EC%A0%84%EB%9E%B5.html" rel="alternate" type="text/html" title="Git branch" /><published>2025-08-20T00:00:00+00:00</published><updated>2025-08-20T00:00:00+00:00</updated><id>https://naming123.github.io/git&amp;project/2025/08/20/%5BProject4%5D%20GitBranch%EA%B4%80%EB%A6%AC%EC%A0%84%EB%9E%B5</id><content type="html" xml:base="https://naming123.github.io/git&amp;project/2025/08/20/Project4-GitBranch%EA%B4%80%EB%A6%AC%EC%A0%84%EB%9E%B5.html"><![CDATA[<p><img src="/assets/images/0806/0806-1.png" alt="banner" /></p>

<p>git branch관리 전략은 어떻게 할가?</p>

<hr />

<p>참고자료</p>
<ul>
  <li>
    <p><a href="https://velog.io/@bbbb_0221/Git-git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90-%EA%B5%AC%EC%A1%B0-%EA%B0%84%EB%8B%A8-%EC%82%AC%EC%9A%A9%EB%B2%95">Git구조</a></p>
  </li>
  <li>
    <p><a href="https://velog.io/@couchcoding/Git-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%93%A4%EC%9D%84-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-1">Git명령어조합</a></p>
  </li>
</ul>]]></content><author><name>GitHub User</name></author><category term="Git&amp;Project" /><category term="git" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">멀티쓰레드</title><link href="https://naming123.github.io/easycode/2025/08/19/easy6-%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C(withJAVA).html" rel="alternate" type="text/html" title="멀티쓰레드" /><published>2025-08-19T00:00:00+00:00</published><updated>2025-08-19T00:00:00+00:00</updated><id>https://naming123.github.io/easycode/2025/08/19/%5Beasy6%5D%20%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C(withJAVA)</id><content type="html" xml:base="https://naming123.github.io/easycode/2025/08/19/easy6-%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C(withJAVA).html"><![CDATA[<p>JAVA의 가장 큰 장점은 운영체제 호환성과 더불어 멀티쓰레드 조작이다.</p>

<ol>
  <li>동시성(Concurrency)과 병렬성(Parallelism)
동시성: 여러 요청이 거의 동시에 들어오더라도, CPU 한 코어를 빠르게 번갈아가며 실행하여 마치 동시에 처리하는 것처럼 보이게 하는 기술.</li>
</ol>

<p>병렬성: CPU 여러 코어에서 실제로 동시에 실행하는 것.</p>

<p>Java는 멀티스레드와 <strong>스레드풀(ExecutorService)</strong>로 이 두 가지를 모두 활용할 수 있어, 수천~수만 개의 요청을 효율적으로 분배 처리할 수 있습니다.</p>

<hr />

<p>참고자료</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=QmtYKZC0lMU&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&amp;index=6">쉬운코드) 백발백중 6강</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="easycode" /><category term="easycode" /><summary type="html"><![CDATA[JAVA의 가장 큰 장점은 운영체제 호환성과 더불어 멀티쓰레드 조작이다.]]></summary></entry><entry><title type="html">인수분해</title><link href="https://naming123.github.io/java/2025/08/19/%EB%B0%B1%EC%A4%806-%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4.html" rel="alternate" type="text/html" title="인수분해" /><published>2025-08-19T00:00:00+00:00</published><updated>2025-08-19T00:00:00+00:00</updated><id>https://naming123.github.io/java/2025/08/19/%5B%EB%B0%B1%EC%A4%806%5D%20%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4</id><content type="html" xml:base="https://naming123.github.io/java/2025/08/19/%EB%B0%B1%EC%A4%806-%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4.html"><![CDATA[<p><img src="/assets/images/0814/전개식코드" alt="banner" /></p>

<p>괄호로 많이 묶는게 빠를까? 전개식으로 푸는게 더 빠를까?</p>

<h3 id="1-이론적-관점">1. 이론적 관점</h3>

<p>괄호로 묶어서 공통 계산을 줄이는 방식 → 연산 횟수 최소화 → CPU 사이클 절약.</p>

<p>전개식 → 같은 부분을 여러 번 곱하거나 더해야 하므로 보통 느림.</p>

<p>예:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 괄호 활용
int x = (a+b) * (c+d);   // a+b, c+d 각각 1번만 계산

// 전개식
int x = a*c + a*d + b*c + b*d;   // 곱 4번, 덧셈 3번
</code></pre></div></div>

<p>두 식은 결과가 같지만 연산 횟수는 다름.</p>

<h3 id="2-실제-실행-시">2. 실제 실행 시</h3>

<p><strong>컴파일러 최적화(O1~O3)</strong>가 걸리면, 대부분의 언어(C, C++, Java, Python JIT 등)에서 자동으로 공통 부분식 제거(common subexpression elimination) 를 해줍니다.
→ 즉, (a+b)가 여러 번 반복되면 한 번만 계산해두도록 바꿔줌.</p>

<p>따라서 단순 수학식 수준에서는 괄호로 묶거나 전개하거나 속도 차이는 거의 없음.</p>

<h3 id="3-차이가-나는-경우">3. 차이가 나는 경우</h3>

<p>반복문 안에서 동일한 식을 계속 계산할 때:
전개식에서는 같은 연산을 반복할 위험 있음.
괄호로 묶어서 변수를 캐싱하면 확실히 빨라짐.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (...) {
    int t1 = a+b;
    int t2 = c+d;
    x = t1 * t2;   // 최적
}
</code></pre></div></div>

<p>동적 언어(Python, JS): 컴파일러 최적화가 제한적이어서, 직접 묶어주는 게 훨씬 효율적.</p>

<p>GPU 연산(딥러닝, 병렬 연산): 곱셈/덧셈의 수가 전체 메모리 대역폭이나 병렬 스케줄링에 직접 영향을 줌 → 괄호 묶기(연산 최소화)가 유리.</p>

<h3 id="4-큰-수에-대한-시간복잡도">4. 큰 수에 대한 시간복잡도</h3>

<p>그래서 큰 수에 대한 부분을 시간으로 어떻게 계산하는게 맞을까?
<img src="/assets/images/0819/0819-1.png" alt="N과 시간제한의 관계" /></p>

<hr />

<p>참고자료 (문제)</p>]]></content><author><name>GitHub User</name></author><category term="JAVA" /><category term="JAVA" /><category term="Baekjoon" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">객체지향과 메모리구조</title><link href="https://naming123.github.io/easycode/2025/08/18/easy4-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A0%91%EA%B7%BC.html" rel="alternate" type="text/html" title="객체지향과 메모리구조" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://naming123.github.io/easycode/2025/08/18/%5Beasy4%5D%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A0%91%EA%B7%BC</id><content type="html" xml:base="https://naming123.github.io/easycode/2025/08/18/easy4-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A0%91%EA%B7%BC.html"><![CDATA[<p>백발백중 4번째 강의는 객체지향의 요소들이 물리적 메모리에 어떻게 저장되고 움직이는가를 말한다.</p>

<p><img src="/assets/images/0814/easy4.jpg" alt="쉬운코드 4" /></p>

<h3 id="1-메모리구조">1. 메모리구조</h3>

<p>컴퓨터의 물리적 메모리 공간은 다음과 같이 이해할 수 있다.
이 메모리 공간은 용도에 따라 여러 영역으로 나뉘는데,
대표적으로 코드(Code) 영역, 데이터(Data) 영역, 힙(Heap) 영역, 스택(Stack) 영역이 있다.</p>

<p>코드 영역은 실행할 프로그램의 기계어 명령이 저장되는 공간이고,
데이터 영역은 프로그램 시작부터 종료까지 유지되는 전역 변수·정적 변수가 저장된다.
Heap 영역은 동적으로 생성되는 객체가 저장되며, Stack 영역은 함수 호출 시 생성되는 지역 변수와 매개변수, 그리고 호출 순서를 저장한다.</p>

<p><img src="/assets/images/0814/easy5.jpg" alt="물리적구조" /></p>

<p>이 중에서 Stack과 Heap은 Java에서 메모리 관리와 직접적으로 연결된다.
Stack 영역은 메서드 호출 시 생성되는 변수들을 저장하는 공간으로, 메서드가 종료되면 해당 영역이 자동으로 해제된다.
객체 그 자체보다는 포인터, 주소와 같은것을 다루는 곳이며
재귀 호출을 무한히 반복하거나 깊이가 과도해지면 <strong>Stack Overflow</strong>라는 런타임 오류가 발생한다.
반면 Heap 영역은 new 연산자로 생성된 객체가 저장되는 공간이며, 프로그램 전체에서 공유된다.
(JAVA에서 변수의 유효범위와는 무관하다.)
Heap 메모리를 잘 관리하지 않으면 <strong>OutOfMemoryError</strong>가 발생할 수 있다.</p>

<h3 id="2-값-타입-vs-참조-타입">2. 값 타입 vs 참조 타입</h3>

<p>Java에서 변수는 Stack에 저장되고,
이 변수가 값 타입(Primitive Type)일 경우 값 자체를, 참조 타입(Reference Type)일 경우 Heap에 있는 객체의 주소를 저장한다.
<strong>객체(값)는 Heap에 저장된 실체 데이터로, 참조 변수가 있어야 접근 가능</strong>하다.
값 타입에는 byte, short, int, long, float, double, char, boolean이 있으며, 값 복사 시 독립적으로 존재하므로 서로 영향을 주지 않는다.
반면 참조 타입은 주소를 복사하므로, 같은 객체를 가리키는 여러 변수가 존재할 수 있고, 한 쪽에서 객체를 변경하면 다른 쪽에도 영향을 준다.
(이에 따라 참조타입인 경우에는 이 변수가 어떤 객체와 연결되어있고 그 객체는 어떤 다른 변수와도 연결되어있는지 이해하며 사용해야한다.)</p>

<h3 id="3-garbage-collector">3. Garbage Collector</h3>

<p>참조변수가 없다면, 해당 객체는 접근할 수도 사용할 수도 없는 객체가 <strong>가비지 객체</strong>가 되어버린다.
이 경우는 쓸모없이 차지하는 가비지 객체들을 없애야하는 Garbage Collector가 필요한데 이를 JAVA에서는 다른 언어에 비해 잘 자동화해놨다.
가비지 컬렉터는 일반적으로 다음과 같은 흐름으로 동작한다.</p>

<ol>
  <li>도달 가능성 분석(Reachability Analysis)</li>
</ol>

<ul>
  <li>프로그램의 실행 스레드, 스택, 전역 변수 등에서 출발해 참조 가능한 객체를 그래프 형태로 추적한다.</li>
  <li>이 경로에 포함되지 않는 객체는 “도달 불가능(Unreachable)” 상태로 간주한다.</li>
</ul>

<ol>
  <li>수집(Mark and Sweep)</li>
</ol>

<ul>
  <li>도달 가능한 객체에 “마크(Mark)”를 표시하고, 마크되지 않은 객체를 힙에서 제거한다.</li>
  <li>필요 시 메모리를 압축(Compaction)하여 조각화를 방지한다.</li>
</ul>

<ol>
  <li>자동 실행 시점</li>
</ol>

<ul>
  <li>GC는 명확한 주기를 따르지 않고, JVM이 메모리 부족을 감지하거나 특정 조건을 만족했을 때 실행된다.</li>
  <li>개발자가 System.gc()를 호출해 요청할 수 있지만, 즉시 실행을 보장하지 않는다.</li>
</ul>

<p>이 방식의 가장 큰 장점은 개발자가 C/C++처럼 free()나 delete를 직접 호출하지 않아도 된다는 점이다. 수동 해제 과정에서 흔히 발생하는 메모리 누수(Leak)나 해제 후 접근(Dangling Pointer)과 같은 위험을 줄여 안정성을 높인다. Java의 자동 메모리 관리 모델은 특히 대규모 애플리케이션과 서버 환경에서 메모리 관리 부담을 크게 덜어주는 강점이 있다.</p>

<p>참고자료</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=GIsr_r8XztQ&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&amp;index=4">쉬운코드) 백발백중 4강</a></li>
  <li><a href="https://www.youtube.com/watch?v=vZRmCbl871I">우아한테코톡) JVM</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="easycode" /><category term="easycode" /><summary type="html"><![CDATA[백발백중 4번째 강의는 객체지향의 요소들이 물리적 메모리에 어떻게 저장되고 움직이는가를 말한다.]]></summary></entry><entry><title type="html">프로세스와 스레드의 차이</title><link href="https://naming123.github.io/easycode/2025/08/18/easy5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%8A%A4%EB%A0%88%EB%93%9C.html" rel="alternate" type="text/html" title="프로세스와 스레드의 차이" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://naming123.github.io/easycode/2025/08/18/%5Beasy5%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%8A%A4%EB%A0%88%EB%93%9C</id><content type="html" xml:base="https://naming123.github.io/easycode/2025/08/18/easy5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%8A%A4%EB%A0%88%EB%93%9C.html"><![CDATA[<p>기술면접에서 나온 질문 중에서 가장 많이 언급되는 질문은
“멀티쓰레드와 멀티프로세스의 차이는?” 이라는 질문이다.</p>

<p><img src="/assets/images/0818/easy5.jpg" alt="banner" /></p>

<p>백엔드, 특히 “대규모트래픽”을 핵심소양으로 생각하는 회사들이라면 기본중의 기본으로 알아야 할 지식이다.</p>

<h4 id="왜그럴까">왜그럴까?</h4>

<p>application을 실행되는 원리는
디스크(SSD/HDD 등)에 저장된 소스코드/컴파일언어로 이루어진 프로그램을 RAM에 올림으로써, 실행된다.</p>

<p>이때 RAM에 올라간 코드들은</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;  // C로 설명해보자
int g = 10;         // 전역 변수

int main() {
    int x = 5;      // 지역 변수
    int *p = malloc(sizeof(int)); // 동적 메모리 할당
    *p = 20;
    printf("%d", g + x + *p);
    return 0;
}
</code></pre></div></div>

<p>*p = 20;같은 힙 따로, x=5; 스택따로 코드 영역, 데이터 영역 따로 만들어지며 하나의 PCB블럭(프로세스)으로 만들어진다.</p>

<p>추가로, 프로세스 ID(PID), 레지스터 값(스냅샷), 메모리 주소 범위, 스케줄링 우선순위, 파일 핸들 정보 등도 같이 포함된다.</p>

<h3 id="1-cpu-스케줄링">1. CPU 스케줄링</h3>

<p>보통의 과정에서는 한 CPU가 여러 프로세스를 실행해야 한다.
이에 따라 원시적으로 CPU는 시분할(Time Sharing) 방식으로 프로세스 P1, P2, P3 등을 번갈아 실행하는 멀티프로그램 방식이었다.</p>
<ul>
  <li>실행 도중 발생하는 Context Switching:</li>
  <li>현재 프로세스 상태(Context)를 저장 → 다른 프로세스로 전환 → 다시 불러오기.</li>
  <li>오버헤드가 크고 성능 손실이 발생함.</li>
</ul>

<h3 id="2-프로세스-vs-스레드">2. 프로세스 vs. 스레드</h3>

<p><img src="/assets/images/0818/taskManager.png" alt="TaskManager" /></p>

<p>같은 실행 파일을 여러 번 실행하면, 동일한 코드라도 서로 다른 프로세스가 생기기는 하지만, 원칙적으로는 하나의 실행 파일 당, <strong>실행하면</strong> 프로세스 하나가 생성된다.</p>

<p>프로세스는 독립된 메모리 공간을 가진</p>

<p>멀티프로세스:</p>

<ul>
  <li>프로세스 단위로 실행, 서로 독립적이라 안전.</li>
  <li>하지만 Context Switching 비용이 큼.</li>
</ul>

<p>멀티스레드:</p>

<ul>
  <li>하나의 프로세스 안에서 여러 스레드가 실행됨.</li>
  <li>메모리를 공유하기 때문에 메모리 사용 효율적이고 빠름.</li>
  <li>하지만 동기화 문제와 자원 충돌 가능성 존재.</li>
</ul>

<h3 id="3-context-switching-비용">3. Context Switching 비용</h3>

<p>프로세스 전환 시:</p>

<ul>
  <li>CPU 레지스터 값, 프로그램 카운터(PC), 메모리 매핑 정보까지 저장/복원 필요.</li>
  <li>큰 오버헤드 발생.</li>
</ul>

<p>스레드 전환 시:</p>
<ul>
  <li>같은 프로세스 내에서 실행 → 공유 메모리를 쓰므로 비교적 가벼움.</li>
</ul>

<ol>
  <li>CPU 아키텍처와 가상화</li>
</ol>

<p>그림에 VM(Virtual Machine)도 등장:</p>

<ul>
  <li>OS 위에 또 다른 OS를 실행하는 방식.</li>
  <li>VM은 하이퍼바이저를 통해 CPU/메모리 자원을 나눔.</li>
  <li>성능 오버헤드가 있음.</li>
</ul>

<p>반대로 <strong>Container(Docker)</strong>는 OS 레벨 가상화라서 훨씬 가볍고 빠름.</p>

<ol>
  <li>운영체제 비교</li>
</ol>

<p>Windows vs Linux 언급:</p>
<ul>
  <li>각각 프로세스/스레드 관리 방식, 시스템 콜 처리 차이.</li>
  <li>일반적으로 Linux가 서버용으로 효율적, Windows는 GUI 기반 사용 편리성 강점.</li>
</ul>

<hr />

<p>참고자료</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=QmtYKZC0lMU&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&amp;index=6">쉬운코드) 백발백중 5강</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="easycode" /><category term="easycode" /><summary type="html"><![CDATA[기술면접에서 나온 질문 중에서 가장 많이 언급되는 질문은 “멀티쓰레드와 멀티프로세스의 차이는?” 이라는 질문이다.]]></summary></entry><entry><title type="html">String vs char vs String[]</title><link href="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%802-CharvsString.html" rel="alternate" type="text/html" title="String vs char vs String[]" /><published>2025-08-14T00:00:00+00:00</published><updated>2025-08-14T00:00:00+00:00</updated><id>https://naming123.github.io/java/2025/08/14/%5B%EB%B0%B1%EC%A4%802%5D%20CharvsString</id><content type="html" xml:base="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%802-CharvsString.html"><![CDATA[<p><img src="/assets/images/0814/(char)banner.jpg" alt="banner" /></p>

<h3 id="1-string-vs-char-vs-string">1. String vs char vs String[]</h3>

<ul>
  <li>char: 한 글자(UTF-16 코드 유닛)</li>
  <li>String: 불변 문자열</li>
  <li>String[]: 문자열들의 배열(가변 길이 아님)</li>
</ul>

<h3 id="2-변환핵심">2. 변환/핵심</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char → String: String.valueOf(c)
String → char: s.charAt(i)
String ↔ char[]: s.toCharArray(), new String(chars)
String ↔ String[]: split(), String.join()
</code></pre></div></div>

<h3 id="3-io-빠르게-문자문자열-중심">3. I/O 빠르게 (문자/문자열 중심)</h3>

<p>1) 입력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line = br.readLine();            // 한 줄
String[] tokens = line.split("\\s+");   // 공백 분리
char c = line.charAt(0);                // 첫 글자
char[] arr = line.toCharArray();        // 전체 문자 배열
</code></pre></div></div>

<p>2) 출력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 한 글자씩
for (char ch : arr) System.out.print(ch);
System.out.println();

// String 배열은 join으로
String[] words = {"A","B","C"};
System.out.println(String.join(",", words)); // A,B,C


주의(배열 “이상한 출력” 방지)

System.out.println(words);                // [Ljava.lang.String;@2f92e0f4
System.out.println(Arrays.toString(words)); // [A, B, C]
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="JAVA" /><category term="JAVA" /><category term="Baekjoon" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">int vs long vs double</title><link href="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%803-%EC%88%AB%EC%9E%90casting.html" rel="alternate" type="text/html" title="int vs long vs double" /><published>2025-08-14T00:00:00+00:00</published><updated>2025-08-14T00:00:00+00:00</updated><id>https://naming123.github.io/java/2025/08/14/%5B%EB%B0%B1%EC%A4%803%5D%20%EC%88%AB%EC%9E%90casting</id><content type="html" xml:base="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%803-%EC%88%AB%EC%9E%90casting.html"><![CDATA[<p><img src="/assets/images/0814/(int)banner.jpg" alt="banner" /></p>

<h3 id="1-범위">1. 범위:</h3>
<p>int(32b) &lt; long(64b), double(64b 부동소수)</p>

<p>리터럴: 1, 1L, 1.0, 3.14F</p>

<p>변환: int→long(자동), long→int(캐스팅), 실수 연산 섞이면 double</p>

<h3 id="2-큰-수거듭제곱">2. 큰 수/거듭제곱</h3>

<p>정수 거듭제곱: 반복 곱 or BigInteger.pow()</p>

<p>Math.pow()는 double 반환 → 정수면 형변환 (long)</p>

<h3 id="3-io-빠르게-숫자-중심">3. I/O 빠르게 (숫자 중심)</h3>

<p>입력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine().trim());
long L = Long.parseLong(br.readLine().trim());
double d = Double.parseDouble(br.readLine().trim());

// 한 줄에 여러 수
String[] t = br.readLine().trim().split("\\s+");
int a = Integer.parseInt(t[0]);
long b = Long.parseLong(t[1]);
double c = Double.parseDouble(t[2]);
</code></pre></div></div>

<p>출력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.out.println(n + " " + L + " " + d);

// 지수표기 피하고 싶을 때(정수로 떨어지는 값)
long v = (long) Math.pow(36, 5);
System.out.println(v); // 60466176

// 포맷팅(소수점 자리수 통제)
System.out.printf("%.6f%n", 3.1415926535); // 3.141593
</code></pre></div></div>

<p>참고자료
https://sirobako.co.kr/detail/54</p>]]></content><author><name>GitHub User</name></author><category term="JAVA" /><category term="JAVA" /><category term="Baekjoon" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">배열</title><link href="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%804-%EB%B0%B0%EC%97%B4.html" rel="alternate" type="text/html" title="배열" /><published>2025-08-14T00:00:00+00:00</published><updated>2025-08-14T00:00:00+00:00</updated><id>https://naming123.github.io/java/2025/08/14/%5B%EB%B0%B1%EC%A4%804%5D%20%EB%B0%B0%EC%97%B4</id><content type="html" xml:base="https://naming123.github.io/java/2025/08/14/%EB%B0%B1%EC%A4%804-%EB%B0%B0%EC%97%B4.html"><![CDATA[<p><img src="/assets/images/0814/(arr)banner.jpg" alt="banner" /></p>

<ul>
  <li>배열(Array): 길이 고정, 원시 타입 가능, 인덱스 O(1)</li>
  <li>List(인터페이스): 순서/중복 허용, 인덱스 메서드 제공</li>
  <li>ArrayList(구현체): 가변 길이 배열 기반 List</li>
  <li>Set: 중복 불가(인덱스 없음)</li>
</ul>

<p>String[], int[]는 “배열”이며, ArrayList<String>은 컬렉션</String></p>

<h3 id="1-인덱스중복탐색">1. 인덱스/중복/탐색</h3>

<p>배열 인덱스: arr[i]</p>

<p>리스트 인덱스: list.get(i), 검색 indexOf(x)</p>

<p>빈도: Collections.frequency(list, x)</p>

<p>맵 사용: 값 집계 Map.merge()</p>

<h3 id="2-io-빠르게-배열리스트">2. I/O 빠르게 (배열/리스트)</h3>

<p>배열 입력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine());
int[] A = new int[n];
String[] tok = br.readLine().split("\\s+");
for (int i = 0; i &lt; n; i++) A[i] = Integer.parseInt(tok[i]);
</code></pre></div></div>

<p>배열 출력 — 반드시 Arrays.toString / deepToString</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.out.println(Arrays.toString(A)); // [1, 2, 3]

int[][] grid = \{\{1,2\},\{3,4\}\};
System.out.println(Arrays.deepToString(grid)); // [[1, 2], [3, 4]]
</code></pre></div></div>

<p>리스트 입력/출력</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
Collections.addAll(list, br.readLine().split("\\s+"));

System.out.println(list);                   // [a, b, c]
System.out.println(String.join(",", list)); // a,b,c
</code></pre></div></div>

<p>Map 출력(정렬 포함)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Map&lt;String,Integer&gt; freq = new HashMap&lt;&gt;();
for (String w : list) freq.merge(w, 1, Integer::sum);

freq.entrySet().stream()
    .sorted(Map.Entry.comparingByKey())
    .forEach(e -&gt; System.out.println(e.getKey() + ": " + e.getValue()));
</code></pre></div></div>

<p>참고자료
https://blog.yevgnenll.me/posts/java-array-list-interfaces-implemented</p>]]></content><author><name>GitHub User</name></author><category term="JAVA" /><category term="JAVA" /><category term="Baekjoon" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">형변환 및 기타조작</title><link href="https://naming123.github.io/easycode/2025/08/14/%EB%B0%B1%EC%A4%805-%ED%98%95%EB%B3%80%ED%99%98%EB%B0%8F%EA%B8%B0%ED%83%80%EC%A1%B0%EC%9E%91.html" rel="alternate" type="text/html" title="형변환 및 기타조작" /><published>2025-08-14T00:00:00+00:00</published><updated>2025-08-14T00:00:00+00:00</updated><id>https://naming123.github.io/easycode/2025/08/14/%5B%EB%B0%B1%EC%A4%805%5D%20%ED%98%95%EB%B3%80%ED%99%98%EB%B0%8F%EA%B8%B0%ED%83%80%EC%A1%B0%EC%9E%91</id><content type="html" xml:base="https://naming123.github.io/easycode/2025/08/14/%EB%B0%B1%EC%A4%805-%ED%98%95%EB%B3%80%ED%99%98%EB%B0%8F%EA%B8%B0%ED%83%80%EC%A1%B0%EC%9E%91.html"><![CDATA[<p><img src="/assets/images/0814/(type)banner.jpg" alt="banner" /></p>

<p>문자열 ↔ 숫자: Integer.parseInt, Long.parseLong, String.valueOf</p>

<p>문자 ↔ 문자열: s.charAt(i), String.valueOf(c), s.toCharArray()</p>

<p>캐스팅: (long)int, (int)double</p>

<p>조건: equals, 문자 판정 Character.isDigit/Letter/UpperCase</p>

<p>반복: “ha”.repeat(3), StringBuilder, for-each, IntStream</p>

<h3 id="1-io-빠르게-변환--조건반복">1. I/O 빠르게 (변환 + 조건/반복)</h3>

<p>문자열 → 숫자</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int x = Integer.parseInt("123");
long y = Long.parseLong("1234567890123");
double z = Double.parseDouble("3.14");
</code></pre></div></div>

<p>숫자 → 문자열</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String s1 = String.valueOf(123);
String s2 = Integer.toString(123);
</code></pre></div></div>

<p>문자/문자열 조건</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char ch = 'A';
if (Character.isDigit(ch)) { /* 숫자 */ }
if ("OK".equals(cmd)) { /* 문자열 비교 */ } // NPE 방지 패턴

// 진법 문자 해석(대문자 가정)
int val = ('0' &lt;= ch &amp;&amp; ch &lt;= '9') ? ch - '0' : (ch - 'A') + 10;
</code></pre></div></div>

<h3 id="2-반복출력-성능-패턴">2. 반복/출력 성능 패턴</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringBuilder sb = new StringBuilder();
for (int v : new int[]{1,2,3}) sb.append(v).append(' ');
System.out.println(sb.toString().trim());

// Java 11+
System.out.println("=".repeat(20));
</code></pre></div></div>

<h3 id="3-에러-방지-팁">3. 에러 방지 팁</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arrays.toString/Arrays.deepToString으로 배열 출력

^(XOR) ≠ 제곱 → 제곱은 반복곱 or Math.pow

큰 정수 리터럴엔 L(예: 3000000000L)

입력 공백은 split("\\s+") + trim() 습관화
</code></pre></div></div>

<p>참고자료
https://techvidvan.com/tutorials/java-type-conversion/</p>]]></content><author><name>GitHub User</name></author><category term="easycode" /><category term="JAVA" /><category term="Baekjoon" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">객체지향과 메모리구조</title><link href="https://naming123.github.io/easycode/2025/08/13/easy1-3-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5.html" rel="alternate" type="text/html" title="객체지향과 메모리구조" /><published>2025-08-13T00:00:00+00:00</published><updated>2025-08-13T00:00:00+00:00</updated><id>https://naming123.github.io/easycode/2025/08/13/%5Beasy1-3%5D%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5</id><content type="html" xml:base="https://naming123.github.io/easycode/2025/08/13/easy1-3-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5.html"><![CDATA[<p>백엔드를 공부하기 위해 유튜브를 찾아보던 중 쉬운코드 유튜브를 발견했다.
거기서 백발백중 재생목록이 백엔드의 큰줄기를 잡기에 좋아보여서 이를 토대로 따라가 보려고 한다.
categories는 easycode로 하겠다.ㄴ</p>

<p><img src="/assets/images/0814/easy1-3.jpg" alt="banner" /></p>

<p>파이썬과 C++처럼, 자바는 객체지향언어로, <strong>클래스·객체·인스턴스·변수·메서드</strong>가 유기적으로 연결되어 있다.
=&gt; 이들은 각각 메모리에 할당하는 방식과 동작방식, 추상화되는계층이 다르기 때문에 정확히 분별하여 이해할 필요가 있다.</p>

<h3 id="1-클래스class와-객체object">1. 클래스(Class)와 객체(Object)</h3>
<ul>
  <li>클래스: 속성과 동작을 정의하는 설계도</li>
  <li>객체: 클래스를 기반으로 메모리에 생성된 실체</li>
</ul>

<p>예시)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Car {
    String color;
    void drive() {
        System.out.println("Driving...");
    }
}

Car myCar = new Car(); // myCar는 객체(인스턴스)
</code></pre></div></div>

<p>객체와 인스턴스는 크게 다르지 않다. 그저 객체 중 클래스를 통해 만들어진 객체를 “인스턴스”라고 한다.</p>

<h3 id="2-method">2. Method</h3>
<p>각 클래스들은 다음의 메서드로 설계도를 구성한다.</p>

<p>메서드 정의 구조: 반환형 + 이름 + 매개변수 목록 + 몸체
(매개변수(args) 특징: // main의 arg는 String[]으로 고정 JLS에 의함)
(python에서 method태그같은 제어자라고 생각하면 된다)</p>

<p>cf) 반환형은  ~~다.</p>

<p>이와 연계되는 Annotation이 있다. (python의 @decorator와 대응된다고 생각하면 된다.)
예시조금 (this -&gt; self / abstract class static..)</p>

<p>예시)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void greet(String name) { 
    System.out.println("Hello " + name);
}
</code></pre></div></div>

<h3 id="3-변수">3. 변수</h3>

<ul>
  <li>인스턴스 변수: 객체별로 고유한 값 저장</li>
  <li>클래스 변수(static): 클래스 안의 모든 인스턴스가 공유</li>
  <li>지역 변수: 메서드 내부에서만 사용 가능</li>
  <li>매개변수(Parameter): 메서드 호출 시 전달받는 값 <em>(하드코딩을 하지 않기 위해 대신 입력공간을 만들어 놓음)</em></li>
</ul>

<p>예시)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Example {
    static int sharedCount; // 클래스 변수
    int id;                 // 인스턴스 변수
    void setId(int id) {    // 매개변수
        this.id = id;
    }
}
</code></pre></div></div>

<hr />

<p>참고자료</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=1pZjXnev45A&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET">쉬운코드) 백발백중 1강</a></li>
  <li><a href="https://www.youtube.com/watch?v=jOI2GG4hVz4&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&amp;index=2">쉬운코드) 백발백중 2강</a></li>
  <li><a href="https://www.youtube.com/watch?v=2bL2mVXGr4I&amp;list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&amp;index=3">쉬운코드) 백발백중 3강</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="easycode" /><category term="easycode" /><summary type="html"><![CDATA[백엔드를 공부하기 위해 유튜브를 찾아보던 중 쉬운코드 유튜브를 발견했다. 거기서 백발백중 재생목록이 백엔드의 큰줄기를 잡기에 좋아보여서 이를 토대로 따라가 보려고 한다. categories는 easycode로 하겠다.ㄴ]]></summary></entry></feed>